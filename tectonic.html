<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>Tectonic Rätsel Generator</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        * {
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f0f0f0;
            min-height: 100vh;
            min-height: 100dvh;
            margin: 0;
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .container {
            max-width: 500px;
            width: 100%;
            padding: 15px;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 20px;
            font-size: clamp(1.5rem, 5vw, 2rem);
            font-weight: 600;
        }

        .controls {
            background: white;
            border-radius: 10px;
            padding: 12px 15px;
            margin-top: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .control-row {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
            justify-content: center;
        }

        select, button {
            padding: 10px 0;
            font-size: 0.9rem;
            border-radius: 6px;
            border: 1px solid #ddd;
            cursor: pointer;
            transition: all 0.2s;
            width: 80px;
            text-align: center;
            text-align-last: center;
        }

        select:focus {
            outline: none;
            border-color: #666;
        }

        button {
            background: #333;
            color: white;
            border: none;
            font-weight: 500;
        }

        button:hover {
            background: #555;
        }

        button:active {
            transform: translateY(0);
        }

        .btn-secondary {
            background: #4a9d4a;
        }
        
        .btn-secondary:hover {
            background: #3d8a3d;
        }

        .btn-warning {
            background: #888;
        }
        
        .btn-warning:hover {
            background: #666;
        }

        .game-area {
            background: white;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            position: relative;
        }

        .grid-container {
            display: flex;
            justify-content: center;
            padding: 8px;
            overflow: visible;
        }

        .grid {
            display: grid;
            gap: 0;
            background: white;
            overflow: visible;
            position: relative;
            padding: 0;
        }

        .cell {
            width: clamp(40px, 10vw, 60px);
            height: clamp(40px, 10vw, 60px);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(1.2rem, 4vw, 1.8rem);
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            user-select: none;
            -webkit-user-select: none;
            box-sizing: border-box;
            overflow: visible;
        }

        /* Dünne graue Linien im Hintergrund */
        .cell::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-right: 1px solid #bbb;
            border-bottom: 1px solid #bbb;
            z-index: 1;
            pointer-events: none;
        }
        
        .cell.edge-right::before { border-right: none; }
        .cell.edge-bottom::before { border-bottom: none; }

        .cell:hover {
            filter: brightness(0.95);
        }

        .cell.given {
            color: #333;
        }

        .cell.user-input {
            color: #0066cc;
        }
        
        .cell.solution-new {
            color: #cc0000;
        }

        .cell.error {
            background-color: #ffcccc !important;
        }

        .cell.correct {
            background-color: #ccffcc !important;
        }


        /* Dicke schwarze Bereichsgrenzen im Vordergrund */
        .cell .border-line {
            position: absolute;
            background-color: #222;
            z-index: 20;
            pointer-events: none;
        }

        /* Innere Linien: mit Überlappung für saubere Ecken */
        .cell .border-line.top {
            top: -1px;
            left: -2px;
            right: -2px;
            height: 3px;
        }

        .cell .border-line.bottom {
            bottom: -1px;
            left: -2px;
            right: -2px;
            height: 3px;
        }

        .cell .border-line.left {
            top: -2px;
            left: -1px;
            bottom: -2px;
            width: 3px;
        }

        .cell .border-line.right {
            top: -2px;
            right: -1px;
            bottom: -2px;
            width: 3px;
        }
        
        /* Außenrand: 1px dicker um gleich wie innen auszusehen */
        .cell .border-line.top.edge { top: 0; height: 4px; }
        .cell .border-line.bottom.edge { bottom: 0; height: 4px; }
        .cell .border-line.left.edge { left: 0; width: 4px; }
        .cell .border-line.right.edge { right: 0; width: 4px; }
        
        /* Ecken am Außenrand: keine Überlappung nach außen */
        .cell.edge-left .border-line.top,
        .cell.edge-left .border-line.bottom { left: 0; }
        
        .cell.edge-right .border-line.top,
        .cell.edge-right .border-line.bottom { right: 0; }
        
        .cell.edge-top .border-line.left,
        .cell.edge-top .border-line.right { top: 0; }
        
        .cell.edge-bottom .border-line.left,
        .cell.edge-bottom .border-line.right { bottom: 0; }

        .number-pad {
            display: flex;
            justify-content: center;
            gap: 8px;
            flex-wrap: wrap;
            margin-top: 12px;
        }

        .num-btn {
            width: 40px;
            height: 40px;
            font-size: 1.2rem;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .num-btn.active {
            box-shadow: 0 0 0 3px rgba(0, 102, 204, 0.4);
        }

        .message {
            text-align: center;
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
            font-weight: 600;
            display: none;
            font-size: 0.9rem;
        }

        .message.success {
            background: #d4edda;
            color: #155724;
            display: block;
        }

        .message.error {
            background: #f8d7da;
            color: #721c24;
            display: block;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255,255,255,0.9);
            padding: 15px 25px;
            border-radius: 8px;
            font-size: 0.9rem;
            color: #666;
            display: none;
            z-index: 50;
        }

        .loading.active {
            display: block;
        }

        .btn-info {
            background: #666;
        }
        
        .btn-info:hover {
            background: #555;
        }
        
        .btn-fullscreen {
            background: #666;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 44px;
            min-width: 44px;
        }
        
        .btn-fullscreen:hover {
            background: #555;
        }
        
        .btn-fullscreen svg {
            width: 18px;
            height: 18px;
        }

        /* Popup Styles */
        .popup-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 100;
            justify-content: center;
            align-items: center;
        }
        
        .popup-overlay.active {
            display: flex;
        }
        
        .popup {
            background: white;
            border-radius: 10px;
            max-width: 400px;
            margin: 20px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }
        
        .popup-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            border-bottom: 1px solid #eee;
            font-weight: 600;
        }
        
        .popup-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            color: #666;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            line-height: 1;
        }
        
        .popup-close:hover {
            color: #333;
            background: none;
        }
        
        .popup-content {
            padding: 15px;
            color: #555;
            line-height: 1.6;
        }
        
        .popup-content p {
            margin: 0 0 10px 0;
        }
        
        .popup-content p:last-child {
            margin-bottom: 0;
        }

        /* Bereichsfarben - exakt wie im Beispiel */
        .region-0 { background-color: #FFCDD2; } /* Rosa */
        .region-1 { background-color: #C8E6C9; } /* Grün */
        .region-2 { background-color: #FFF9C4; } /* Gelb */
        .region-3 { background-color: #BBDEFB; } /* Blau */

        @media (max-width: 500px) {
            .container {
                padding: 10px;
            }
            .controls {
                padding: 10px;
            }
            .control-row {
                gap: 4px;
            }
            select, button {
                padding: 8px 0;
                font-size: 0.75rem;
                width: 58px;
            }
            .btn-fullscreen {
                width: 40px;
                min-width: 40px;
            }
            .btn-fullscreen svg {
                width: 16px;
                height: 16px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="game-area">
            <div class="grid-container">
                <div class="grid" id="grid"></div>
            </div>
            
            <div class="loading" id="loading">Rätsel wird generiert...</div>
            
            <div class="number-pad" id="numberPad"></div>
            
            <div class="message" id="message"></div>
        </div>

        <div class="controls">
            <div class="control-row">
                <select id="sizeSelect" onchange="generatePuzzle()">
                    <option value="4">4 × 4</option>
                    <option value="5">5 × 5</option>
                    <option value="6" selected>6 × 6</option>
                    <option value="7">7 × 7</option>
                </select>
                <select id="difficultySelect" onchange="generatePuzzle()">
                    <option value="easy">Einfach</option>
                    <option value="medium" selected>Mittel</option>
                    <option value="hard">Schwer</option>
                </select>
                <button onclick="generatePuzzle()">Neu</button>
                <button class="btn-secondary" onclick="checkSolution()">Prüfen</button>
                <button class="btn-warning" onclick="showSolution()">Lösung</button>
                <button class="btn-info" onclick="toggleRules()">Regeln</button>
                <button class="btn-fullscreen" id="fullscreenButton" title="Vollbild">
                    <svg class="fullscreen-icon expand" viewBox="0 0 24 24">
                        <path d="M3 3h6v2H5v4H3V3zm12 0h6v6h-2V5h-4V3zM3 15h2v4h4v2H3v-6zm16 0h2v6h-6v-2h4v-4z" fill="currentColor"/>
                    </svg>
                    <svg class="fullscreen-icon collapse" viewBox="0 0 24 24" style="display:none;">
                        <path d="M9 9H3V7h4V3h2v6zm6 0V3h2v4h4v2h-6zM9 15H3v2h4v4h2v-6zm6 0v6h2v-4h4v-2h-6z" fill="currentColor"/>
                    </svg>
                </button>
            </div>
        </div>
        
        <!-- Regeln Popup -->
        <div class="popup-overlay" id="rulesOverlay" onclick="toggleRules()">
            <div class="popup" onclick="event.stopPropagation()">
                <div class="popup-header">
                    <span>Spielregeln</span>
                    <button class="popup-close" onclick="toggleRules()">×</button>
                </div>
                <div class="popup-content">
                    <p><strong>Ziel:</strong> Fülle jeden Bereich mit den Zahlen 1 bis zur Größe des Bereichs.</p>
                    <p>Ein 3er-Bereich enthält 1, 2, 3 – ein 5er-Bereich enthält 1, 2, 3, 4, 5.</p>
                    <p><strong>Regel:</strong> Gleiche Zahlen dürfen sich nicht berühren – weder horizontal, vertikal noch diagonal.</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        let grid = [];
        let regions = [];
        let solution = [];
        let givenCells = []; // Speichert welche Zellen ursprünglich vorgegeben waren
        let regionColors = []; // Farbzuweisung für jeden Bereich
        let regionSizeCache = {}; // Cache für Bereichsgrößen
        let regionCellsCache = {}; // Cache für Bereichszellen
        let selectedCell = null;
        let gridSize = 6;
        let maxNumber = 5;

        // Initialisierung
        document.addEventListener('DOMContentLoaded', () => {
            generatePuzzle();
        });

        let loadingStartTime = 0;
        const MIN_LOADING_TIME = 400; // Mindestens 400ms anzeigen
        
        function generatePuzzle() {
            // Lade-Indikator anzeigen (über bestehendem Grid)
            document.getElementById('loading').classList.add('active');
            loadingStartTime = Date.now();
            
            // Kurze Verzögerung damit der Browser die UI aktualisieren kann
            setTimeout(() => {
                doGeneratePuzzle(0);
            }, 10);
        }
        
        function hideLoadingWithDelay(callback) {
            const elapsed = Date.now() - loadingStartTime;
            const remaining = MIN_LOADING_TIME - elapsed;
            
            if (remaining > 0) {
                setTimeout(() => {
                    document.getElementById('loading').classList.remove('active');
                    if (callback) callback();
                }, remaining);
            } else {
                document.getElementById('loading').classList.remove('active');
                if (callback) callback();
            }
        }
        
        function doGeneratePuzzle(totalAttempts) {
            gridSize = parseInt(document.getElementById('sizeSelect').value);
            const difficulty = document.getElementById('difficultySelect').value;
            
            // Reset
            selectedCell = null;
            document.getElementById('message').className = 'message';
            document.getElementById('message').textContent = '';

            let attempts = 0;
            const maxAttempts = 10;
            
            while (attempts < maxAttempts) {
                attempts++;
                totalAttempts++;
                
                // Bereiche generieren
                grid = [];
                regions = [];
                solution = [];
                regionSizeCache = {};
                regionCellsCache = {};
                generateRegions();
                
                // Farben für Bereiche zuweisen
                assignRegionColors();
                
                // Maximale Zahl bestimmen
                maxNumber = getMaxRegionSize();

                // Lösung generieren
                if (generateSolution()) {
                    // Erfolg!
                    createPuzzleFromSolution(difficulty);
                    hideLoadingWithDelay(() => {
                        renderGrid();
                        renderNumberPad();
                    });
                    return;
                }
            }
            
            // Noch nicht gefunden - asynchron weitermachen
            if (totalAttempts < 100) {
                setTimeout(() => doGeneratePuzzle(totalAttempts), 0);
            } else {
                // Nochmal von vorne
                setTimeout(() => doGeneratePuzzle(0), 0);
            }
        }

        function generateRegions() {
            // Initialisiere leeres Regionen-Array
            regions = Array(gridSize).fill(null).map(() => Array(gridSize).fill(-1));
            
            let regionId = 0;
            const cells = [];
            
            // Alle Zellen sammeln
            for (let r = 0; r < gridSize; r++) {
                for (let c = 0; c < gridSize; c++) {
                    cells.push({r, c});
                }
            }
            
            // Zellen mischen
            shuffleArray(cells);
            
            // Bereiche erstellen (max. Größe 5)
            for (const cell of cells) {
                if (regions[cell.r][cell.c] === -1) {
                    const regionSize = Math.floor(Math.random() * 4) + 2; // 2-5 Zellen
                    growRegion(cell.r, cell.c, regionId, Math.min(regionSize, 5));
                    regionId++;
                }
            }
            
            // Einzelne Zellen zu Nachbarn hinzufügen
            for (let r = 0; r < gridSize; r++) {
                for (let c = 0; c < gridSize; c++) {
                    if (getRegionSizeUncached(regions[r][c]) === 1) {
                        // Finde benachbarten Bereich mit Größe < 5 und füge hinzu
                        const neighbors = getOrthogonalNeighbors(r, c);
                        shuffleArray(neighbors);
                        for (const neighbor of neighbors) {
                            if (getRegionSizeUncached(regions[neighbor.r][neighbor.c]) < 5) {
                                regions[r][c] = regions[neighbor.r][neighbor.c];
                                break;
                            }
                        }
                    }
                }
            }
        }
        
        function getRegionSizeUncached(regionId) {
            let count = 0;
            for (let r = 0; r < gridSize; r++) {
                for (let c = 0; c < gridSize; c++) {
                    if (regions[r][c] === regionId) count++;
                }
            }
            return count;
        }

        function growRegion(startR, startC, regionId, targetSize) {
            const queue = [{r: startR, c: startC}];
            regions[startR][startC] = regionId;
            let size = 1;
            
            while (queue.length > 0 && size < targetSize) {
                const current = queue[Math.floor(Math.random() * queue.length)];
                const neighbors = getOrthogonalNeighbors(current.r, current.c)
                    .filter(n => regions[n.r][n.c] === -1);
                
                if (neighbors.length > 0) {
                    const next = neighbors[Math.floor(Math.random() * neighbors.length)];
                    regions[next.r][next.c] = regionId;
                    queue.push(next);
                    size++;
                } else {
                    queue.splice(queue.indexOf(current), 1);
                }
            }
        }

        function getOrthogonalNeighbors(r, c) {
            const neighbors = [];
            const dirs = [[-1, 0], [1, 0], [0, -1], [0, 1]];
            for (const [dr, dc] of dirs) {
                const nr = r + dr;
                const nc = c + dc;
                if (nr >= 0 && nr < gridSize && nc >= 0 && nc < gridSize) {
                    neighbors.push({r: nr, c: nc});
                }
            }
            return neighbors;
        }

        function getAllNeighbors(r, c) {
            const neighbors = [];
            for (let dr = -1; dr <= 1; dr++) {
                for (let dc = -1; dc <= 1; dc++) {
                    if (dr === 0 && dc === 0) continue;
                    const nr = r + dr;
                    const nc = c + dc;
                    if (nr >= 0 && nr < gridSize && nc >= 0 && nc < gridSize) {
                        neighbors.push({r: nr, c: nc});
                    }
                }
            }
            return neighbors;
        }

        function getRegionSize(regionId) {
            if (regionSizeCache[regionId] !== undefined) {
                return regionSizeCache[regionId];
            }
            let count = 0;
            for (let r = 0; r < gridSize; r++) {
                for (let c = 0; c < gridSize; c++) {
                    if (regions[r][c] === regionId) count++;
                }
            }
            regionSizeCache[regionId] = count;
            return count;
        }

        function getMaxRegionSize() {
            const regionSizes = {};
            for (let r = 0; r < gridSize; r++) {
                for (let c = 0; c < gridSize; c++) {
                    const id = regions[r][c];
                    regionSizes[id] = (regionSizes[id] || 0) + 1;
                }
            }
            return Math.max(...Object.values(regionSizes));
        }

        function getRegionCells(regionId) {
            if (regionCellsCache[regionId] !== undefined) {
                return regionCellsCache[regionId];
            }
            const cells = [];
            for (let r = 0; r < gridSize; r++) {
                for (let c = 0; c < gridSize; c++) {
                    if (regions[r][c] === regionId) {
                        cells.push({r, c});
                    }
                }
            }
            regionCellsCache[regionId] = cells;
            return cells;
        }

        function generateSolution() {
            solution = Array(gridSize).fill(null).map(() => Array(gridSize).fill(0));
            solverIterations = 0;
            return solvePuzzleOptimized();
        }

        let solverIterations = 0;
        const MAX_ITERATIONS = 50000;

        function solvePuzzleOptimized() {
            solverIterations++;
            if (solverIterations > MAX_ITERATIONS) {
                return false; // Abbruch - zu lange
            }
            
            // Finde Zelle mit wenigsten Möglichkeiten (MRV Heuristik)
            let minOptions = Infinity;
            let bestCell = null;
            
            for (let r = 0; r < gridSize; r++) {
                for (let c = 0; c < gridSize; c++) {
                    if (solution[r][c] === 0) {
                        const options = getValidNumbers(r, c);
                        if (options.length === 0) return false; // Keine Lösung möglich
                        if (options.length < minOptions) {
                            minOptions = options.length;
                            bestCell = {r, c, options};
                        }
                    }
                }
            }
            
            // Alle Zellen gefüllt = fertig
            if (!bestCell) return true;
            
            // Versuche alle Optionen für diese Zelle
            shuffleArray(bestCell.options);
            for (const num of bestCell.options) {
                solution[bestCell.r][bestCell.c] = num;
                if (solvePuzzleOptimized()) return true;
                solution[bestCell.r][bestCell.c] = 0;
            }
            
            return false;
        }

        function getValidNumbers(row, col) {
            const regionId = regions[row][col];
            const regionSize = getRegionSize(regionId);
            const valid = [];
            
            for (let num = 1; num <= regionSize; num++) {
                if (isValidPlacement(solution, row, col, num)) {
                    valid.push(num);
                }
            }
            return valid;
        }

        function solvePuzzle(board, row, col) {
            // Nicht mehr verwendet, aber für Kompatibilität behalten
            return solvePuzzleOptimized();
        }

        function isValidPlacement(board, row, col, num) {
            // Prüfe alle 8 Nachbarn
            const neighbors = getAllNeighbors(row, col);
            for (const n of neighbors) {
                if (board[n.r][n.c] === num) return false;
            }
            
            // Prüfe ob Zahl bereits im Bereich ist
            const regionId = regions[row][col];
            const regionCells = getRegionCells(regionId);
            for (const cell of regionCells) {
                if (cell.r === row && cell.c === col) continue;
                if (board[cell.r][cell.c] === num) return false;
            }
            
            return true;
        }

        function createPuzzleFromSolution(difficulty) {
            // Kopiere Lösung
            grid = solution.map(row => [...row]);
            
            // Alle Zellen sammeln und mischen
            const cells = [];
            for (let r = 0; r < gridSize; r++) {
                for (let c = 0; c < gridSize; c++) {
                    cells.push({r, c});
                }
            }
            shuffleArray(cells);
            
            // Erlaubte Techniken je nach Schwierigkeit
            let allowedTechniques;
            let targetRemove;
            const totalCells = gridSize * gridSize;
            
            switch (difficulty) {
                case 'easy':
                    allowedTechniques = ['nakedSingles']; // Nur einfachste Technik
                    targetRemove = Math.floor(totalCells * 0.5);
                    break;
                case 'medium':
                    allowedTechniques = ['nakedSingles', 'hiddenSingles'];
                    targetRemove = Math.floor(totalCells * 0.6);
                    break;
                case 'hard':
                    allowedTechniques = ['nakedSingles', 'hiddenSingles', 'elimination'];
                    targetRemove = Math.floor(totalCells * 0.7);
                    break;
            }
            
            // Versuche Zellen zu entfernen, solange Rätsel mit erlaubten Techniken lösbar bleibt
            let removed = 0;
            for (const cell of cells) {
                if (removed >= targetRemove) break;
                
                const {r, c} = cell;
                const backup = grid[r][c];
                grid[r][c] = 0;
                
                // Prüfe ob noch mit erlaubten Techniken lösbar
                if (isSolvableWith(allowedTechniques)) {
                    removed++;
                } else {
                    // Nicht lösbar mit erlaubten Techniken - Zahl zurück
                    grid[r][c] = backup;
                }
            }
            
            // Speichere welche Zellen vorgegeben sind
            givenCells = grid.map(row => row.map(cell => cell !== 0));
        }
        
        // Prüft ob das aktuelle Grid mit bestimmten Techniken lösbar ist
        function isSolvableWith(allowedTechniques) {
            // Kopie des Grids zum Testen
            const testGrid = grid.map(row => [...row]);
            
            // Kandidaten für jede Zelle berechnen
            const candidates = [];
            for (let r = 0; r < gridSize; r++) {
                candidates[r] = [];
                for (let c = 0; c < gridSize; c++) {
                    if (testGrid[r][c] !== 0) {
                        candidates[r][c] = new Set();
                    } else {
                        candidates[r][c] = getCandidates(testGrid, r, c);
                    }
                }
            }
            
            // Logisch lösen mit erlaubten Techniken
            let changed = true;
            while (changed) {
                changed = false;
                
                // Technik 1: Naked Singles (nur eine Möglichkeit in Zelle)
                if (allowedTechniques.includes('nakedSingles')) {
                    for (let r = 0; r < gridSize; r++) {
                        for (let c = 0; c < gridSize; c++) {
                            if (testGrid[r][c] === 0 && candidates[r][c].size === 1) {
                                const value = [...candidates[r][c]][0];
                                testGrid[r][c] = value;
                                candidates[r][c] = new Set();
                                updateCandidates(candidates, testGrid, r, c, value);
                                changed = true;
                            } else if (testGrid[r][c] === 0 && candidates[r][c].size === 0) {
                                return false; // Keine Lösung möglich
                            }
                        }
                    }
                }
                
                // Technik 2: Hidden Singles (Zahl nur an einer Stelle im Bereich möglich)
                if (allowedTechniques.includes('hiddenSingles')) {
                    const regionIds = new Set();
                    for (let r = 0; r < gridSize; r++) {
                        for (let c = 0; c < gridSize; c++) {
                            regionIds.add(regions[r][c]);
                        }
                    }
                    
                    for (const regionId of regionIds) {
                        const regionCells = getRegionCells(regionId);
                        const regionSize = regionCells.length;
                        
                        for (let num = 1; num <= regionSize; num++) {
                            // Finde alle Zellen wo diese Zahl möglich ist
                            const possibleCells = regionCells.filter(({r, c}) => 
                                testGrid[r][c] === 0 && candidates[r][c].has(num)
                            );
                            
                            if (possibleCells.length === 1) {
                                const {r, c} = possibleCells[0];
                                testGrid[r][c] = num;
                                candidates[r][c] = new Set();
                                updateCandidates(candidates, testGrid, r, c, num);
                                changed = true;
                            } else if (possibleCells.length === 0) {
                                // Prüfe ob Zahl schon im Bereich ist
                                const hasNum = regionCells.some(({r, c}) => testGrid[r][c] === num);
                                if (!hasNum) return false; // Keine Lösung möglich
                            }
                        }
                    }
                }
                
                // Technik 3: Elimination (Kandidaten durch Nachbarn eliminieren)
                if (allowedTechniques.includes('elimination')) {
                    for (let r = 0; r < gridSize; r++) {
                        for (let c = 0; c < gridSize; c++) {
                            if (testGrid[r][c] === 0) {
                                const before = candidates[r][c].size;
                                candidates[r][c] = getCandidates(testGrid, r, c);
                                if (candidates[r][c].size < before) {
                                    changed = true;
                                }
                                if (candidates[r][c].size === 0) {
                                    return false;
                                }
                            }
                        }
                    }
                }
            }
            
            // Prüfe ob komplett gelöst
            for (let r = 0; r < gridSize; r++) {
                for (let c = 0; c < gridSize; c++) {
                    if (testGrid[r][c] === 0) {
                        return false; // Nicht vollständig lösbar mit erlaubten Techniken
                    }
                }
            }
            
            return true;
        }
        
        // Berechnet mögliche Kandidaten für eine Zelle
        function getCandidates(testGrid, row, col) {
            const regionId = regions[row][col];
            const regionSize = getRegionSize(regionId);
            const candidates = new Set();
            
            for (let num = 1; num <= regionSize; num++) {
                if (isValidPlacementInGrid(testGrid, row, col, num)) {
                    candidates.add(num);
                }
            }
            
            return candidates;
        }
        
        // Aktualisiert Kandidaten nach Platzierung einer Zahl
        function updateCandidates(candidates, testGrid, row, col, value) {
            // Entferne aus allen Nachbarn
            for (let dr = -1; dr <= 1; dr++) {
                for (let dc = -1; dc <= 1; dc++) {
                    if (dr === 0 && dc === 0) continue;
                    const nr = row + dr;
                    const nc = col + dc;
                    if (nr >= 0 && nr < gridSize && nc >= 0 && nc < gridSize) {
                        candidates[nr][nc].delete(value);
                    }
                }
            }
            
            // Entferne aus allen Zellen im gleichen Bereich
            const regionId = regions[row][col];
            const regionCells = getRegionCells(regionId);
            for (const {r, c} of regionCells) {
                candidates[r][c].delete(value);
            }
        }
        
        // Prüft ob Platzierung gültig ist (für beliebiges Grid)
        function isValidPlacementInGrid(testGrid, row, col, num) {
            // Prüfe alle 8 Nachbarn
            for (let dr = -1; dr <= 1; dr++) {
                for (let dc = -1; dc <= 1; dc++) {
                    if (dr === 0 && dc === 0) continue;
                    const nr = row + dr;
                    const nc = col + dc;
                    if (nr >= 0 && nr < gridSize && nc >= 0 && nc < gridSize) {
                        if (testGrid[nr][nc] === num) return false;
                    }
                }
            }
            
            // Prüfe ob Zahl bereits im Bereich ist
            const regionId = regions[row][col];
            const regionCells = getRegionCells(regionId);
            for (const {r, c} of regionCells) {
                if (r === row && c === col) continue;
                if (testGrid[r][c] === num) return false;
            }
            
            return true;
        }

        function renderGrid() {
            const gridEl = document.getElementById('grid');
            gridEl.innerHTML = '';
            gridEl.style.gridTemplateColumns = `repeat(${gridSize}, 1fr)`;
            
            for (let r = 0; r < gridSize; r++) {
                for (let c = 0; c < gridSize; c++) {
                    const cell = document.createElement('div');
                    const colorIndex = regionColors[regions[r][c]] || 0;
                    cell.className = `cell region-${colorIndex}`;
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    
                    // Edge-Klassen für äußere Zellen
                    const isTop = r === 0;
                    const isBottom = r === gridSize - 1;
                    const isLeft = c === 0;
                    const isRight = c === gridSize - 1;
                    
                    if (isTop) cell.classList.add('edge-top');
                    if (isBottom) cell.classList.add('edge-bottom');
                    if (isLeft) cell.classList.add('edge-left');
                    if (isRight) cell.classList.add('edge-right');
                    
                    // Oben: Außenrand ODER innere Bereichsgrenze
                    if (isTop || regions[r-1][c] !== regions[r][c]) {
                        const line = document.createElement('div');
                        line.className = 'border-line top' + (isTop ? ' edge' : '');
                        cell.appendChild(line);
                    }
                    // Unten: Außenrand ODER innere Bereichsgrenze
                    if (isBottom || regions[r+1][c] !== regions[r][c]) {
                        const line = document.createElement('div');
                        line.className = 'border-line bottom' + (isBottom ? ' edge' : '');
                        cell.appendChild(line);
                    }
                    // Links: Außenrand ODER innere Bereichsgrenze
                    if (isLeft || regions[r][c-1] !== regions[r][c]) {
                        const line = document.createElement('div');
                        line.className = 'border-line left' + (isLeft ? ' edge' : '');
                        cell.appendChild(line);
                    }
                    // Rechts: Außenrand ODER innere Bereichsgrenze
                    if (isRight || regions[r][c+1] !== regions[r][c]) {
                        const line = document.createElement('div');
                        line.className = 'border-line right' + (isRight ? ' edge' : '');
                        cell.appendChild(line);
                    }
                    
                    // Zahl als separates Span-Element
                    const numSpan = document.createElement('span');
                    numSpan.style.position = 'relative';
                    numSpan.style.zIndex = '5';
                    
                    const value = grid[r][c];
                    if (value !== 0) {
                        numSpan.textContent = value;
                        if (givenCells[r] && givenCells[r][c]) {
                            cell.classList.add('given');
                        } else {
                            cell.classList.add('user-input');
                        }
                    }
                    cell.appendChild(numSpan);
                    
                    cell.addEventListener('click', () => selectCell(r, c));
                    gridEl.appendChild(cell);
                }
            }
        }

        function renderNumberPad() {
            const pad = document.getElementById('numberPad');
            pad.innerHTML = '';
            
            const maxNum = getMaxRegionSize();
            
            for (let n = 1; n <= maxNum; n++) {
                const btn = document.createElement('button');
                btn.className = 'num-btn';
                btn.textContent = n;
                btn.addEventListener('click', () => enterNumber(n));
                pad.appendChild(btn);
            }
            
            // Löschen-Button
            const clearBtn = document.createElement('button');
            clearBtn.className = 'num-btn btn-warning';
            clearBtn.textContent = '✕';
            clearBtn.addEventListener('click', () => enterNumber(0));
            pad.appendChild(clearBtn);
        }

        function selectCell(r, c) {
            // Prüfmodus-Markierungen entfernen
            document.querySelectorAll('.cell').forEach(cell => {
                cell.classList.remove('error', 'correct');
            });
            document.getElementById('message').className = 'message';
            
            // Entferne alte Auswahl
            document.querySelectorAll('.cell').forEach(cell => {
                cell.style.boxShadow = '';
            });
            
            selectedCell = {r, c};
            
            // Markiere ausgewählte Zelle
            const cells = document.querySelectorAll('.cell');
            const index = r * gridSize + c;
            cells[index].style.boxShadow = 'inset 0 0 0 3px #667eea';
        }

        function enterNumber(num) {
            if (!selectedCell) return;
            
            const {r, c} = selectedCell;
            
            // Prüfe ob es eine ursprünglich vorgegebene Zahl ist
            if (givenCells[r] && givenCells[r][c]) {
                // Ursprünglich gegebene Zahl - nicht änderbar
                return;
            }
            
            grid[r][c] = num;
            
            // Aktualisiere Anzeige
            const cells = document.querySelectorAll('.cell');
            const index = r * gridSize + c;
            const cell = cells[index];
            const numSpan = cell.querySelector('span');
            
            numSpan.textContent = num === 0 ? '' : num;
            cell.classList.remove('given', 'error', 'user-input', 'correct');
            if (num !== 0) {
                cell.classList.add('user-input');
            }
            
            // Verstecke Nachricht
            document.getElementById('message').className = 'message';
        }

        function checkSolution() {
            let correct = true;
            const cells = document.querySelectorAll('.cell');
            
            for (let r = 0; r < gridSize; r++) {
                for (let c = 0; c < gridSize; c++) {
                    const index = r * gridSize + c;
                    const cell = cells[index];
                    
                    // Erst alle Markierungen entfernen
                    cell.classList.remove('error', 'correct');
                    
                    if (grid[r][c] === 0) {
                        correct = false;
                        cell.classList.add('error');
                    } else if (grid[r][c] !== solution[r][c]) {
                        correct = false;
                        cell.classList.add('error');
                    } else {
                        cell.classList.add('correct');
                    }
                }
            }
            
            const message = document.getElementById('message');
            if (correct) {
                message.className = 'message success';
                message.textContent = 'Fantastisch! Das Rätsel ist korrekt gelöst!';
            } else {
                message.className = 'message error';
                message.textContent = 'Es gibt noch Fehler. Die rot markierten Felder stimmen nicht.';
            }
            
            // Markierungen bleiben bis Benutzer etwas ändert
        }

        function showSolution() {
            if (!confirm('Möchtest du wirklich die Lösung sehen?')) return;
            
            grid = solution.map(row => [...row]);
            renderGrid();
            
            // Nur ursprünglich nicht vorgegebene Felder rot markieren
            const cells = document.querySelectorAll('.cell');
            for (let r = 0; r < gridSize; r++) {
                for (let c = 0; c < gridSize; c++) {
                    const index = r * gridSize + c;
                    if (!givenCells[r][c]) {
                        cells[index].classList.remove('user-input');
                        cells[index].classList.add('solution-new');
                    }
                }
            }
        }

        function updateDifficultyInfo() {
            // Nicht mehr angezeigt
        }

        function getUniqueRegionCount() {
            const unique = new Set();
            for (let r = 0; r < gridSize; r++) {
                for (let c = 0; c < gridSize; c++) {
                    unique.add(regions[r][c]);
                }
            }
            return unique.size;
        }

        function assignRegionColors() {
            // Finde alle einzigartigen Regionen
            const uniqueRegions = new Set();
            for (let r = 0; r < gridSize; r++) {
                for (let c = 0; c < gridSize; c++) {
                    uniqueRegions.add(regions[r][c]);
                }
            }
            
            // Baue Nachbarschaftsgraph
            const neighbors = {};
            for (const id of uniqueRegions) {
                neighbors[id] = new Set();
            }
            
            for (let r = 0; r < gridSize; r++) {
                for (let c = 0; c < gridSize; c++) {
                    const currentRegion = regions[r][c];
                    // Prüfe alle 4 Nachbarn
                    const dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]];
                    for (const [dr, dc] of dirs) {
                        const nr = r + dr;
                        const nc = c + dc;
                        if (nr >= 0 && nr < gridSize && nc >= 0 && nc < gridSize) {
                            const neighborRegion = regions[nr][nc];
                            if (neighborRegion !== currentRegion) {
                                neighbors[currentRegion].add(neighborRegion);
                            }
                        }
                    }
                }
            }
            
            // Graph-Coloring mit 4 Farben
            regionColors = {};
            const sortedRegions = [...uniqueRegions].sort((a, b) => 
                neighbors[b].size - neighbors[a].size
            );
            
            for (const regionId of sortedRegions) {
                const usedColors = new Set();
                for (const neighborId of neighbors[regionId]) {
                    if (regionColors[neighborId] !== undefined) {
                        usedColors.add(regionColors[neighborId]);
                    }
                }
                
                // Finde erste freie Farbe
                for (let color = 0; color < 4; color++) {
                    if (!usedColors.has(color)) {
                        regionColors[regionId] = color;
                        break;
                    }
                }
            }
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }
        
        function toggleRules() {
            const overlay = document.getElementById('rulesOverlay');
            overlay.classList.toggle('active');
        }
        
        // Fullscreen Funktionalität
        const fullscreenButton = document.getElementById('fullscreenButton');
        
        fullscreenButton.addEventListener('click', () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.log('Fullscreen nicht möglich:', err);
                });
            } else {
                document.exitFullscreen();
            }
        });
        
        document.addEventListener('fullscreenchange', () => {
            const expandIcon = fullscreenButton.querySelector('.expand');
            const collapseIcon = fullscreenButton.querySelector('.collapse');
            if (document.fullscreenElement) {
                expandIcon.style.display = 'none';
                collapseIcon.style.display = 'block';
                fullscreenButton.title = 'Vollbild beenden';
            } else {
                expandIcon.style.display = 'block';
                collapseIcon.style.display = 'none';
                fullscreenButton.title = 'Vollbild';
            }
        });
    </script>
</body>
</html>
